# API Service Template
# Optimized for REST APIs and microservices
# Focuses on performance, security, and monitoring

name: api-template
arch: "x86_64"
images:
  - location: "https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img"
    arch: "x86_64"
    digest: "sha256:1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"

# Resource allocation - optimized for API workloads
cpus: 1
memory: "2GiB"
disk: "10GiB"

# Mount host directories for data and logs
mounts:
  - location: "~/.lima/api/{{.Name}}/data"
    writable: true
    mountPoint: "/data"
  - location: "~/.lima/api/{{.Name}}/logs"
    writable: true
    mountPoint: "/var/log/api"

# SSH configuration
ssh:
  localPort: 0
  loadDotSSHPubKeys: true
  forwardAgent: false
  forwardX11: false

# Container runtime configuration
containerd:
  system: true
  user: true

# Port forwarding for API services
portForwards:
  - guestPort: 8080
    hostPort: 8080
    proto: "tcp"
  - guestPort: 8443
    hostPort: 8443
    proto: "tcp"
  - guestPort: 9090
    hostPort: 9090
    proto: "tcp"   # For metrics

# Network configuration
networks:
  - lima: shared

# Provisioning scripts
provision:
  # System-level provisioning
  - mode: system
    script: |
      #!/bin/bash
      set -eux -o pipefail
      
      export DEBIAN_FRONTEND=noninteractive
      apt-get update
      apt-get upgrade -y
      
      # Install essential packages
      apt-get install -y \
        curl \
        wget \
        git \
        nginx \
        logrotate \
        fail2ban \
        ufw \
        prometheus-node-exporter \
        grafana-agent
      
      # Configure firewall
      ufw --force enable
      ufw allow ssh
      ufw allow 8080
      ufw allow 8443
      ufw allow 9090
      
      # Create API user
      useradd -m -s /bin/bash apiuser || true
      usermod -aG docker apiuser
      
      # Create necessary directories
      mkdir -p /api /data /var/log/api
      chown -R apiuser:apiuser /api /data /var/log/api
      
      # Configure log rotation for API logs
      cat > /etc/logrotate.d/api << EOF
      /var/log/api/*.log {
          daily
          missingok
          rotate 14
          compress
          delaycompress
          notifempty
          create 644 apiuser apiuser
          postrotate
              systemctl reload nginx || true
          endscript
      }
      EOF
      
      # Optimize system for API workloads
      cat >> /etc/sysctl.conf << EOF
      # API optimization
      net.core.somaxconn = 65535
      net.ipv4.tcp_max_syn_backlog = 65535
      net.ipv4.tcp_tw_reuse = 1
      net.ipv4.tcp_fin_timeout = 10
      net.ipv4.tcp_keepalive_time = 60
      net.ipv4.tcp_keepalive_intvl = 10
      net.ipv4.tcp_keepalive_probes = 6
      net.ipv4.ip_local_port_range = 10000 65535
      net.core.netdev_max_backlog = 10000
      EOF
      
      sysctl -p
      
      # Create systemd service for API monitoring
      cat > /etc/systemd/system/api-monitor.service << 'EOF'
      [Unit]
      Description=API Health Monitor
      After=network.target docker.service
      
      [Service]
      Type=simple
      User=apiuser
      WorkingDirectory=/api
      ExecStart=/usr/local/bin/api-monitor
      Restart=always
      RestartSec=10
      
      [Install]
      WantedBy=multi-user.target
      EOF

  # Install container runtime
  - mode: system
    script: |
      #!/bin/bash
      set -eux -o pipefail
      
      apt-get install -y containerd
      
      mkdir -p /etc/containerd
      containerd config default > /etc/containerd/config.toml
      
      # Optimize containerd for API workloads
      sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml
      
      systemctl restart containerd
      systemctl enable containerd
      
      # Install nerdctl
      curl -sSL https://github.com/containerd/nerdctl/releases/download/v1.7.0/nerdctl-1.7.0-linux-amd64.tar.gz | tar -xz -C /usr/local/bin

  # Configure Nginx for API gateway
  - mode: system
    script: |
      #!/bin/bash
      set -eux -o pipefail
      
      mkdir -p /etc/nginx/sites-available /etc/nginx/sites-enabled
      
      # Nginx configuration optimized for APIs
      cat > /etc/nginx/nginx.conf << 'EOF'
      user www-data;
      worker_processes auto;
      pid /run/nginx.pid;
      include /etc/nginx/modules-enabled/*.conf;
      
      events {
          worker_connections 1024;
          use epoll;
          multi_accept on;
      }
      
      http {
          sendfile on;
          tcp_nopush on;
          tcp_nodelay on;
          keepalive_timeout 30;
          keepalive_requests 1000;
          types_hash_max_size 2048;
          server_tokens off;
          
          include /etc/nginx/mime.types;
          default_type application/octet-stream;
          
          # Rate limiting
          limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
          limit_req_zone $binary_remote_addr zone=login:10m rate=5r/m;
          
          # Security headers
          add_header X-Frame-Options "SAMEORIGIN" always;
          add_header X-Content-Type-Options "nosniff" always;
          add_header X-XSS-Protection "1; mode=block" always;
          add_header Referrer-Policy "strict-origin-when-cross-origin" always;
          
          # SSL configuration
          ssl_protocols TLSv1.2 TLSv1.3;
          ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
          ssl_prefer_server_ciphers off;
          ssl_session_cache shared:SSL:10m;
          ssl_session_timeout 1d;
          
          # Logging
          log_format api '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for" '
                      'rt=$request_time uct="$upstream_connect_time" '
                      'uht="$upstream_header_time" urt="$upstream_response_time"';
          
          access_log /var/log/nginx/access.log api;
          error_log /var/log/nginx/error.log warn;
          
          # Gzip compression for API responses
          gzip on;
          gzip_vary on;
          gzip_proxied any;
          gzip_comp_level 6;
      gzip_types
          application/atom+xml
          application/javascript
          application/json
          application/ld+json
          application/manifest+json
          application/rss+xml
          application/vnd.geo+json
          application/vnd.ms-fontobject
          application/x-font-ttf
          application/x-web-app-manifest+json
          application/xhtml+xml
          application/xml
          font/opentype
          image/bmp
          image/svg+xml
          image/x-icon
          text/cache-manifest
          text/css
          text/plain
          text/vcard
          text/vnd.rim.location.xloc
          text/vtt
          text/x-component
          text/x-cross-domain-policy;
          
          include /etc/nginx/conf.d/*.conf;
          include /etc/nginx/sites-enabled/*;
      }
      EOF
      
      # API gateway configuration
      cat > /etc/nginx/sites-available/api-gateway << 'EOF'
      server {
          listen 80;
          server_name _;
          return 301 https://$host$request_uri;
      }
      
      server {
          listen 8443 ssl http2;
          server_name _;
          
          ssl_certificate /etc/ssl/certs/api-cert.pem;
          ssl_certificate_key /etc/ssl/private/api-key.pem;
          
          # Security
          limit_req zone=api burst=20 nodelay;
          
          # Health check endpoint
          location /health {
              access_log off;
              return 200 "OK";
              add_header Content-Type text/plain;
          }
          
          # Metrics endpoint (protected)
          location /metrics {
              allow 127.0.0.1;
              deny all;
              proxy_pass http://127.0.0.1:9090/metrics;
          }
          
          # API endpoints
          location / {
              proxy_pass http://127.0.0.1:8080;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
              
              # Timeouts
              proxy_connect_timeout 5s;
              proxy_send_timeout 60s;
              proxy_read_timeout 60s;
              
              # Buffer settings
              proxy_buffering on;
              proxy_buffer_size 4k;
              proxy_buffers 8 4k;
              
              # Headers
              proxy_set_header Connection "";
              proxy_http_version 1.1;
          }
          
          # Static files (if needed)
          location /static/ {
              alias /api/static/;
              expires 1y;
              add_header Cache-Control "public, immutable";
          }
      }
      EOF
      
      # Generate self-signed SSL certificate for development
      mkdir -p /etc/ssl/certs /etc/ssl/private
      openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
          -keyout /etc/ssl/private/api-key.pem \
          -out /etc/ssl/certs/api-cert.pem \
          -subj "/C=US/ST=State/L=City/O=Organization/CN=localhost"
      
      nginx -t
      ln -sf /etc/nginx/sites-available/api-gateway /etc/nginx/sites-enabled/
      systemctl restart nginx
      systemctl enable nginx

  # User-level provisioning
  - mode: user
    script: |
      #!/bin/bash
      set -eux -o pipefail
      
      mkdir -p ~/api ~/logs ~/data ~/monitoring
      
      # Create docker-compose template for APIs
      cat > ~/api/docker-compose.yml.template << 'EOF'
      version: '3.8'
      
      services:
        api:
          image: ${API_IMAGE}
          container_name: ${API_NAME}
          restart: unless-stopped
          ports:
            - "8080:8080"
          environment:
            - NODE_ENV=${NODE_ENV}
            - PORT=8080
            - DATABASE_URL=${DATABASE_URL}
            - REDIS_URL=${REDIS_URL}
            - JWT_SECRET=${JWT_SECRET}
            - LOG_LEVEL=${LOG_LEVEL}
          volumes:
            - ../data:/app/data
            - ../logs:/app/logs
          networks:
            - api-network
          depends_on:
            - redis
          healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
            interval: 15s
            timeout: 5s
            retries: 3
          deploy:
            resources:
              limits:
                cpus: '0.5'
                memory: 512M
              reservations:
                cpus: '0.1'
                memory: 128M
        
        redis:
          image: redis:7-alpine
          container_name: ${API_NAME}-redis
          restart: unless-stopped
          ports:
            - "6379:6379"
          volumes:
            - ../data/redis:/data
          networks:
            - api-network
          command: redis-server --appendonly yes
          healthcheck:
            test: ["CMD", "redis-cli", "ping"]
            interval: 30s
            timeout: 5s
            retries: 3
        
        prometheus:
          image: prom/prometheus:latest
          container_name: ${API_NAME}-prometheus
          restart: unless-stopped
          ports:
            - "9090:9090"
          volumes:
            - ../monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
            - ../monitoring/data:/prometheus
          command:
            - '--config.file=/etc/prometheus/prometheus.yml'
            - '--storage.tsdb.path=/prometheus'
            - '--web.console.libraries=/etc/prometheus/console_libraries'
            - '--web.console.templates=/etc/prometheus/consoles'
            - '--storage.tsdb.retention.time=200h'
            - '--web.enable-lifecycle'
          networks:
            - api-network
      
      networks:
        api-network:
          driver: bridge
      EOF
      
      # Create Prometheus configuration
      mkdir -p ~/monitoring
      cat > ~/monitoring/prometheus.yml << 'EOF'
      global:
        scrape_interval: 15s
        evaluation_interval: 15s
      
      rule_files:
        - "alert_rules.yml"
      
      scrape_configs:
        - job_name: 'api'
          static_configs:
            - targets: ['api:8080']
          metrics_path: '/metrics'
          scrape_interval: 5s
        
        - job_name: 'redis'
          static_configs:
            - targets: ['redis:6379']
          scrape_interval: 15s
      
        - job_name: 'node'
          static_configs:
            - targets: ['localhost:9100']
          scrape_interval: 15s
      
      alerting:
        alertmanagers:
          - static_configs:
              - targets:
                - alertmanager:9093
      EOF
      
      # Create API deployment script
      cat > ~/api/deploy.sh << 'EOF'
      #!/bin/bash
      set -eu
      
      export API_IMAGE="${1:-node:18-alpine}"
      export API_NAME="${2:-myapi}"
      export NODE_ENV="${3:-production}"
      export DATABASE_URL="${4:-}"
      export REDIS_URL="${5:-redis://redis:6379}"
      export JWT_SECRET="${6:-$(openssl rand -hex 32)}"
      export LOG_LEVEL="${7:-info}"
      
      cp docker-compose.yml.template docker-compose.yml
      sed -i "s|\${API_IMAGE}|$API_IMAGE|g" docker-compose.yml
      sed -i "s|\${API_NAME}|$API_NAME|g" docker-compose.yml
      sed -i "s|\${NODE_ENV}|$NODE_ENV|g" docker-compose.yml
      sed -i "s|\${DATABASE_URL}|$DATABASE_URL|g" docker-compose.yml
      sed -i "s|\${REDIS_URL}|$REDIS_URL|g" docker-compose.yml
      sed -i "s|\${JWT_SECRET}|$JWT_SECRET|g" docker-compose.yml
      sed -i "s|\${LOG_LEVEL}|$LOG_LEVEL|g" docker-compose.yml
      
      docker-compose down
      docker-compose pull
      docker-compose up -d
      
      echo "API deployed successfully!"
      echo "Health check: http://localhost:8080/health"
      echo "Metrics: http://localhost:9090"
      EOF
      
      chmod +x ~/api/deploy.sh

# Health checks
probes:
  - mode: readiness
    description: Check containerd
    script: |
      #!/bin/bash
      systemctl is-active --quiet containerd
  - mode: readiness
    description: Check Nginx
    script: |
      #!/bin/bash
      systemctl is-active --quiet nginx
  - mode: readiness
    description: Check Docker
    script: |
      #!/bin/bash
      docker info >/dev/null 2>&1

# Message for users
message: |
  API service template has been successfully created!
  
  Features included:
  - Ubuntu 22.04 LTS
  - Container runtime with resource limits
  - Nginx API gateway with SSL
  - Redis for caching
  - Prometheus monitoring
  - Rate limiting and security headers
  - Optimized for API workloads
  
  Quick start:
  1. Deploy your API:
      cd ~/api
      ./deploy.sh <image> <name> <env> <db-url> <redis-url> <jwt-secret> <log-level>
  
  2. Check health:
      curl http://localhost:8080/health
  
  3. View metrics:
      http://localhost:9090
  
  4. View logs:
      docker-compose logs -f api